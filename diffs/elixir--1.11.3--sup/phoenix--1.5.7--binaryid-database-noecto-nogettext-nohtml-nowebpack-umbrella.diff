diff --git .formatter.exs .formatter.exs
index d2cda26..6915976 100644
--- .formatter.exs
+++ .formatter.exs
@@ -1,4 +1,4 @@
-# Used by "mix format"
 [
-  inputs: ["{mix,.formatter}.exs", "{config,lib,test}/**/*.{ex,exs}"]
+  inputs: ["mix.exs", "config/*.exs"],
+  subdirectories: ["apps/*"]
 ]
diff --git .gitignore .gitignore
index 2be4a13..12179ea 100644
--- .gitignore
+++ .gitignore
@@ -7,7 +7,7 @@
 # The directory Mix downloads your dependencies sources to.
 /deps/
 
-# Where third-party dependencies like ExDoc output generated docs.
+# Where 3rd-party dependencies like ExDoc output generated docs.
 /doc/
 
 # Ignore .fetch files in case you like to edit your project deps locally.
@@ -18,10 +18,3 @@ erl_crash.dump
 
 # Also ignore archive artifacts (built via "mix archive.build").
 *.ez
-
-# Ignore package tarball (built via "mix hex.build").
-my_app-*.tar
-
-
-# Temporary files for e.g. tests
-/tmp
diff --git README.md README.md
index a0b6bf0..729adca 100644
--- README.md
+++ README.md
@@ -1,21 +1 @@
-# MyApp
-
-**TODO: Add description**
-
-## Installation
-
-If [available in Hex](https://hex.pm/docs/publish), the package can be installed
-by adding `my_app` to your list of dependencies in `mix.exs`:
-
-```elixir
-def deps do
-  [
-    {:my_app, "~> 0.1.0"}
-  ]
-end
-```
-
-Documentation can be generated with [ExDoc](https://github.com/elixir-lang/ex_doc)
-and published on [HexDocs](https://hexdocs.pm). Once published, the docs can
-be found at [https://hexdocs.pm/my_app](https://hexdocs.pm/my_app).
-
+# MyApp.Umbrella
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app/.formatter.exs apps/my_app/.formatter.exs
new file mode 100644
index 0000000..3d8ce11
--- /dev/null
+++ apps/my_app/.formatter.exs
@@ -0,0 +1,3 @@
+[
+  inputs: ["*.{ex,exs}", "{config,lib,test}/**/*.{ex,exs}"]
+]
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app/.gitignore apps/my_app/.gitignore
new file mode 100644
index 0000000..992da6d
--- /dev/null
+++ apps/my_app/.gitignore
@@ -0,0 +1,23 @@
+# The directory Mix will write compiled artifacts to.
+/_build/
+
+# If you run "mix test --cover", coverage assets end up here.
+/cover/
+
+# The directory Mix downloads your dependencies sources to.
+/deps/
+
+# Where 3rd-party dependencies like ExDoc output generated docs.
+/doc/
+
+# Ignore .fetch files in case you like to edit your project deps locally.
+/.fetch
+
+# If the VM crashes, it generates a dump, let's ignore it too.
+erl_crash.dump
+
+# Also ignore archive artifacts (built via "mix archive.build").
+*.ez
+
+# Ignore package tarball (built via "mix hex.build").
+my_app-*.tar
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app/README.md apps/my_app/README.md
new file mode 100644
index 0000000..4a0521a
--- /dev/null
+++ apps/my_app/README.md
@@ -0,0 +1,3 @@
+# MyApp
+
+**TODO: Add description**
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app/lib/my_app/application.ex apps/my_app/lib/my_app/application.ex
new file mode 100644
index 0000000..d968a2f
--- /dev/null
+++ apps/my_app/lib/my_app/application.ex
@@ -0,0 +1,18 @@
+defmodule MyApp.Application do
+  # See https://hexdocs.pm/elixir/Application.html
+  # for more information on OTP Applications
+  @moduledoc false
+
+  use Application
+
+  def start(_type, _args) do
+    children = [
+      # Start the PubSub system
+      {Phoenix.PubSub, name: MyApp.PubSub}
+      # Start a worker by calling: MyApp.Worker.start_link(arg)
+      # {MyApp.Worker, arg}
+    ]
+
+    Supervisor.start_link(children, strategy: :one_for_one, name: MyApp.Supervisor)
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app/lib/my_app.ex apps/my_app/lib/my_app.ex
new file mode 100644
index 0000000..ee0175f
--- /dev/null
+++ apps/my_app/lib/my_app.ex
@@ -0,0 +1,9 @@
+defmodule MyApp do
+  @moduledoc """
+  MyApp keeps the contexts that define your domain
+  and business logic.
+
+  Contexts are also responsible for managing your data, regardless
+  if it comes from the database, an external API or others.
+  """
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app/mix.exs apps/my_app/mix.exs
new file mode 100644
index 0000000..07cf694
--- /dev/null
+++ apps/my_app/mix.exs
@@ -0,0 +1,51 @@
+defmodule MyApp.MixProject do
+  use Mix.Project
+
+  def project do
+    [
+      app: :my_app,
+      version: "0.1.0",
+      build_path: "../../_build",
+      config_path: "../../config/config.exs",
+      deps_path: "../../deps",
+      lockfile: "../../mix.lock",
+      elixir: "~> 1.7",
+      elixirc_paths: elixirc_paths(Mix.env()),
+      start_permanent: Mix.env() == :prod,
+      aliases: aliases(),
+      deps: deps()
+    ]
+  end
+
+  # Configuration for the OTP application.
+  #
+  # Type `mix help compile.app` for more information.
+  def application do
+    [
+      mod: {MyApp.Application, []},
+      extra_applications: [:logger, :runtime_tools]
+    ]
+  end
+
+  # Specifies which paths to compile per environment.
+  defp elixirc_paths(:test), do: ["lib", "test/support"]
+  defp elixirc_paths(_), do: ["lib"]
+
+  # Specifies your project dependencies.
+  #
+  # Type `mix help deps` for examples and options.
+  defp deps do
+    [
+      {:phoenix_pubsub, "~> 2.0"}
+    ]
+  end
+
+  # Aliases are shortcuts or tasks specific to the current project.
+  #
+  # See the documentation for `Mix` for more info on aliases.
+  defp aliases do
+    [
+      setup: ["deps.get"]
+    ]
+  end
+end
diff --git test/test_helper.exs apps/my_app/test/test_helper.exs
similarity index 100%
rename from projects/elixir/1.11.3/sup/test/test_helper.exs
rename to projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app/test/test_helper.exs
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/.formatter.exs apps/my_app_web/.formatter.exs
new file mode 100644
index 0000000..4761678
--- /dev/null
+++ apps/my_app_web/.formatter.exs
@@ -0,0 +1,4 @@
+[
+  import_deps: [:phoenix],
+  inputs: ["*.{ex,exs}", "{config,lib,test}/**/*.{ex,exs}"]
+]
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/.gitignore apps/my_app_web/.gitignore
new file mode 100644
index 0000000..ea0dd82
--- /dev/null
+++ apps/my_app_web/.gitignore
@@ -0,0 +1,28 @@
+# The directory Mix will write compiled artifacts to.
+/_build/
+
+# If you run "mix test --cover", coverage assets end up here.
+/cover/
+
+# The directory Mix downloads your dependencies sources to.
+/deps/
+
+# Where 3rd-party dependencies like ExDoc output generated docs.
+/doc/
+
+# Ignore .fetch files in case you like to edit your project deps locally.
+/.fetch
+
+# If the VM crashes, it generates a dump, let's ignore it too.
+erl_crash.dump
+
+# Also ignore archive artifacts (built via "mix archive.build").
+*.ez
+
+# Ignore package tarball (built via "mix hex.build").
+my_app_web-*.tar
+
+# Since we are building assets from assets/,
+# we ignore priv/static. You may want to comment
+# this depending on your deployment strategy.
+/priv/static/
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/README.md apps/my_app_web/README.md
new file mode 100644
index 0000000..4dcdde3
--- /dev/null
+++ apps/my_app_web/README.md
@@ -0,0 +1,18 @@
+# MyAppWeb
+
+To start your Phoenix server:
+
+  * Install dependencies with `mix deps.get`
+  * Start Phoenix endpoint with `mix phx.server`
+
+Now you can visit [`localhost:4000`](http://localhost:4000) from your browser.
+
+Ready to run in production? Please [check our deployment guides](https://hexdocs.pm/phoenix/deployment.html).
+
+## Learn more
+
+  * Official website: https://www.phoenixframework.org/
+  * Guides: https://hexdocs.pm/phoenix/overview.html
+  * Docs: https://hexdocs.pm/phoenix
+  * Forum: https://elixirforum.com/c/phoenix-forum
+  * Source: https://github.com/phoenixframework/phoenix
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/lib/my_app_web/application.ex apps/my_app_web/lib/my_app_web/application.ex
new file mode 100644
index 0000000..fbdce53
--- /dev/null
+++ apps/my_app_web/lib/my_app_web/application.ex
@@ -0,0 +1,30 @@
+defmodule MyAppWeb.Application do
+  # See https://hexdocs.pm/elixir/Application.html
+  # for more information on OTP Applications
+  @moduledoc false
+
+  use Application
+
+  def start(_type, _args) do
+    children = [
+      # Start the Telemetry supervisor
+      MyAppWeb.Telemetry,
+      # Start the Endpoint (http/https)
+      MyAppWeb.Endpoint
+      # Start a worker by calling: MyAppWeb.Worker.start_link(arg)
+      # {MyAppWeb.Worker, arg}
+    ]
+
+    # See https://hexdocs.pm/elixir/Supervisor.html
+    # for other strategies and supported options
+    opts = [strategy: :one_for_one, name: MyAppWeb.Supervisor]
+    Supervisor.start_link(children, opts)
+  end
+
+  # Tell Phoenix to update the endpoint configuration
+  # whenever the application is updated.
+  def config_change(changed, _new, removed) do
+    MyAppWeb.Endpoint.config_change(changed, removed)
+    :ok
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/lib/my_app_web/channels/user_socket.ex apps/my_app_web/lib/my_app_web/channels/user_socket.ex
new file mode 100644
index 0000000..2b7368f
--- /dev/null
+++ apps/my_app_web/lib/my_app_web/channels/user_socket.ex
@@ -0,0 +1,35 @@
+defmodule MyAppWeb.UserSocket do
+  use Phoenix.Socket
+
+  ## Channels
+  # channel "room:*", MyAppWeb.RoomChannel
+
+  # Socket params are passed from the client and can
+  # be used to verify and authenticate a user. After
+  # verification, you can put default assigns into
+  # the socket that will be set for all channels, ie
+  #
+  #     {:ok, assign(socket, :user_id, verified_user_id)}
+  #
+  # To deny connection, return `:error`.
+  #
+  # See `Phoenix.Token` documentation for examples in
+  # performing token verification on connect.
+  @impl true
+  def connect(_params, socket, _connect_info) do
+    {:ok, socket}
+  end
+
+  # Socket id's are topics that allow you to identify all sockets for a given user:
+  #
+  #     def id(socket), do: "user_socket:#{socket.assigns.user_id}"
+  #
+  # Would allow you to broadcast a "disconnect" event and terminate
+  # all active sockets and channels for a given user:
+  #
+  #     MyAppWeb.Endpoint.broadcast("user_socket:#{user.id}", "disconnect", %{})
+  #
+  # Returning `nil` makes this socket anonymous.
+  @impl true
+  def id(_socket), do: nil
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/lib/my_app_web/endpoint.ex apps/my_app_web/lib/my_app_web/endpoint.ex
new file mode 100644
index 0000000..638d644
--- /dev/null
+++ apps/my_app_web/lib/my_app_web/endpoint.ex
@@ -0,0 +1,51 @@
+defmodule MyAppWeb.Endpoint do
+  use Phoenix.Endpoint, otp_app: :my_app_web
+
+  # The session will be stored in the cookie and signed,
+  # this means its contents can be read but not tampered with.
+  # Set :encryption_salt if you would also like to encrypt it.
+  @session_options [
+    store: :cookie,
+    key: "_my_app_web_key",
+    signing_salt: "uCI5HpDL"
+  ]
+
+  socket "/socket", MyAppWeb.UserSocket,
+    websocket: true,
+    longpoll: false
+
+  socket "/live", Phoenix.LiveView.Socket, websocket: [connect_info: [session: @session_options]]
+
+  # Serve at "/" the static files from "priv/static" directory.
+  #
+  # You should set gzip to true if you are running phx.digest
+  # when deploying your static files in production.
+  plug Plug.Static,
+    at: "/",
+    from: :my_app_web,
+    gzip: false,
+    only: ~w(css fonts images js favicon.ico robots.txt)
+
+  # Code reloading can be explicitly enabled under the
+  # :code_reloader configuration of your endpoint.
+  if code_reloading? do
+    plug Phoenix.CodeReloader
+  end
+
+  plug Phoenix.LiveDashboard.RequestLogger,
+    param_key: "request_logger",
+    cookie_key: "request_logger"
+
+  plug Plug.RequestId
+  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]
+
+  plug Plug.Parsers,
+    parsers: [:urlencoded, :multipart, :json],
+    pass: ["*/*"],
+    json_decoder: Phoenix.json_library()
+
+  plug Plug.MethodOverride
+  plug Plug.Head
+  plug Plug.Session, @session_options
+  plug MyAppWeb.Router
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/lib/my_app_web/router.ex apps/my_app_web/lib/my_app_web/router.ex
new file mode 100644
index 0000000..4abdff1
--- /dev/null
+++ apps/my_app_web/lib/my_app_web/router.ex
@@ -0,0 +1,27 @@
+defmodule MyAppWeb.Router do
+  use MyAppWeb, :router
+
+  pipeline :api do
+    plug :accepts, ["json"]
+  end
+
+  scope "/api", MyAppWeb do
+    pipe_through :api
+  end
+
+  # Enables LiveDashboard only for development
+  #
+  # If you want to use the LiveDashboard in production, you should put
+  # it behind authentication and allow only admins to access it.
+  # If your application does not have an admins-only section yet,
+  # you can use Plug.BasicAuth to set up some basic authentication
+  # as long as you are also using SSL (which you should anyway).
+  if Mix.env() in [:dev, :test] do
+    import Phoenix.LiveDashboard.Router
+
+    scope "/" do
+      pipe_through [:fetch_session, :protect_from_forgery]
+      live_dashboard "/dashboard", metrics: MyAppWeb.Telemetry
+    end
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/lib/my_app_web/telemetry.ex apps/my_app_web/lib/my_app_web/telemetry.ex
new file mode 100644
index 0000000..9f50f3d
--- /dev/null
+++ apps/my_app_web/lib/my_app_web/telemetry.ex
@@ -0,0 +1,48 @@
+defmodule MyAppWeb.Telemetry do
+  use Supervisor
+  import Telemetry.Metrics
+
+  def start_link(arg) do
+    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
+  end
+
+  @impl true
+  def init(_arg) do
+    children = [
+      # Telemetry poller will execute the given period measurements
+      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
+      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
+      # Add reporters as children of your supervision tree.
+      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
+    ]
+
+    Supervisor.init(children, strategy: :one_for_one)
+  end
+
+  def metrics do
+    [
+      # Phoenix Metrics
+      summary("phoenix.endpoint.stop.duration",
+        unit: {:native, :millisecond}
+      ),
+      summary("phoenix.router_dispatch.stop.duration",
+        tags: [:route],
+        unit: {:native, :millisecond}
+      ),
+
+      # VM Metrics
+      summary("vm.memory.total", unit: {:byte, :kilobyte}),
+      summary("vm.total_run_queue_lengths.total"),
+      summary("vm.total_run_queue_lengths.cpu"),
+      summary("vm.total_run_queue_lengths.io")
+    ]
+  end
+
+  defp periodic_measurements do
+    [
+      # A module, function and arguments to be invoked periodically.
+      # This function must call :telemetry.execute/3 and a metric must be added above.
+      # {MyAppWeb, :count_users, []}
+    ]
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/lib/my_app_web/views/error_helpers.ex apps/my_app_web/lib/my_app_web/views/error_helpers.ex
new file mode 100644
index 0000000..dd1c1c4
--- /dev/null
+++ apps/my_app_web/lib/my_app_web/views/error_helpers.ex
@@ -0,0 +1,16 @@
+defmodule MyAppWeb.ErrorHelpers do
+  @moduledoc """
+  Conveniences for translating and building error messages.
+  """
+
+  @doc """
+  Translates an error message.
+  """
+  def translate_error({msg, opts}) do
+    # Because the error messages we show in our forms and APIs
+    # are defined inside Ecto, we need to translate them dynamically.
+    Enum.reduce(opts, msg, fn {key, value}, acc ->
+      String.replace(acc, "%{#{key}}", to_string(value))
+    end)
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/lib/my_app_web/views/error_view.ex apps/my_app_web/lib/my_app_web/views/error_view.ex
new file mode 100644
index 0000000..6bc5b14
--- /dev/null
+++ apps/my_app_web/lib/my_app_web/views/error_view.ex
@@ -0,0 +1,16 @@
+defmodule MyAppWeb.ErrorView do
+  use MyAppWeb, :view
+
+  # If you want to customize a particular status code
+  # for a certain format, you may uncomment below.
+  # def render("500.json", _assigns) do
+  #   %{errors: %{detail: "Internal Server Error"}}
+  # end
+
+  # By default, Phoenix returns the status message from
+  # the template name. For example, "404.json" becomes
+  # "Not Found".
+  def template_not_found(template, _assigns) do
+    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/lib/my_app_web.ex apps/my_app_web/lib/my_app_web.ex
new file mode 100644
index 0000000..1f75dac
--- /dev/null
+++ apps/my_app_web/lib/my_app_web.ex
@@ -0,0 +1,75 @@
+defmodule MyAppWeb do
+  @moduledoc """
+  The entrypoint for defining your web interface, such
+  as controllers, views, channels and so on.
+
+  This can be used in your application as:
+
+      use MyAppWeb, :controller
+      use MyAppWeb, :view
+
+  The definitions below will be executed for every view,
+  controller, etc, so keep them short and clean, focused
+  on imports, uses and aliases.
+
+  Do NOT define functions inside the quoted expressions
+  below. Instead, define any helper function in modules
+  and import those modules here.
+  """
+
+  def controller do
+    quote do
+      use Phoenix.Controller, namespace: MyAppWeb
+
+      import Plug.Conn
+      alias MyAppWeb.Router.Helpers, as: Routes
+    end
+  end
+
+  def view do
+    quote do
+      use Phoenix.View,
+        root: "lib/my_app_web/templates",
+        namespace: MyAppWeb
+
+      # Import convenience functions from controllers
+      import Phoenix.Controller,
+        only: [get_flash: 1, get_flash: 2, view_module: 1, view_template: 1]
+
+      # Include shared imports and aliases for views
+      unquote(view_helpers())
+    end
+  end
+
+  def router do
+    quote do
+      use Phoenix.Router
+
+      import Plug.Conn
+      import Phoenix.Controller
+    end
+  end
+
+  def channel do
+    quote do
+      use Phoenix.Channel
+    end
+  end
+
+  defp view_helpers do
+    quote do
+      # Import basic rendering functionality (render, render_layout, etc)
+      import Phoenix.View
+
+      import MyAppWeb.ErrorHelpers
+      alias MyAppWeb.Router.Helpers, as: Routes
+    end
+  end
+
+  @doc """
+  When used, dispatch to the appropriate controller/view/etc.
+  """
+  defmacro __using__(which) when is_atom(which) do
+    apply(__MODULE__, which, [])
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/mix.exs apps/my_app_web/mix.exs
new file mode 100644
index 0000000..24f60f4
--- /dev/null
+++ apps/my_app_web/mix.exs
@@ -0,0 +1,58 @@
+defmodule MyAppWeb.MixProject do
+  use Mix.Project
+
+  def project do
+    [
+      app: :my_app_web,
+      version: "0.1.0",
+      build_path: "../../_build",
+      config_path: "../../config/config.exs",
+      deps_path: "../../deps",
+      lockfile: "../../mix.lock",
+      elixir: "~> 1.7",
+      elixirc_paths: elixirc_paths(Mix.env()),
+      compilers: [:phoenix] ++ Mix.compilers(),
+      start_permanent: Mix.env() == :prod,
+      aliases: aliases(),
+      deps: deps()
+    ]
+  end
+
+  # Configuration for the OTP application.
+  #
+  # Type `mix help compile.app` for more information.
+  def application do
+    [
+      mod: {MyAppWeb.Application, []},
+      extra_applications: [:logger, :runtime_tools]
+    ]
+  end
+
+  # Specifies which paths to compile per environment.
+  defp elixirc_paths(:test), do: ["lib", "test/support"]
+  defp elixirc_paths(_), do: ["lib"]
+
+  # Specifies your project dependencies.
+  #
+  # Type `mix help deps` for examples and options.
+  defp deps do
+    [
+      {:phoenix, "~> 1.5.7"},
+      {:phoenix_live_dashboard, "~> 0.4"},
+      {:telemetry_metrics, "~> 0.4"},
+      {:telemetry_poller, "~> 0.4"},
+      {:my_app, in_umbrella: true},
+      {:jason, "~> 1.0"},
+      {:plug_cowboy, "~> 2.0"}
+    ]
+  end
+
+  # Aliases are shortcuts or tasks specific to the current project.
+  #
+  # See the documentation for `Mix` for more info on aliases.
+  defp aliases do
+    [
+      setup: ["deps.get"]
+    ]
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/test/my_app_web/views/error_view_test.exs apps/my_app_web/test/my_app_web/views/error_view_test.exs
new file mode 100644
index 0000000..05a065b
--- /dev/null
+++ apps/my_app_web/test/my_app_web/views/error_view_test.exs
@@ -0,0 +1,15 @@
+defmodule MyAppWeb.ErrorViewTest do
+  use MyAppWeb.ConnCase, async: true
+
+  # Bring render/3 and render_to_string/3 for testing custom views
+  import Phoenix.View
+
+  test "renders 404.json" do
+    assert render(MyAppWeb.ErrorView, "404.json", []) == %{errors: %{detail: "Not Found"}}
+  end
+
+  test "renders 500.json" do
+    assert render(MyAppWeb.ErrorView, "500.json", []) ==
+             %{errors: %{detail: "Internal Server Error"}}
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/test/support/channel_case.ex apps/my_app_web/test/support/channel_case.ex
new file mode 100644
index 0000000..2a1dfdb
--- /dev/null
+++ apps/my_app_web/test/support/channel_case.ex
@@ -0,0 +1,34 @@
+defmodule MyAppWeb.ChannelCase do
+  @moduledoc """
+  This module defines the test case to be used by
+  channel tests.
+
+  Such tests rely on `Phoenix.ChannelTest` and also
+  import other functionality to make it easier
+  to build common data structures and query the data layer.
+
+  Finally, if the test case interacts with the database,
+  we enable the SQL sandbox, so changes done to the database
+  are reverted at the end of every test. If you are using
+  PostgreSQL, you can even run database tests asynchronously
+  by setting `use MyAppWeb.ChannelCase, async: true`, although
+  this option is not recommended for other databases.
+  """
+
+  use ExUnit.CaseTemplate
+
+  using do
+    quote do
+      # Import conveniences for testing with channels
+      import Phoenix.ChannelTest
+      import MyAppWeb.ChannelCase
+
+      # The default endpoint for testing
+      @endpoint MyAppWeb.Endpoint
+    end
+  end
+
+  setup _tags do
+    :ok
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/test/support/conn_case.ex apps/my_app_web/test/support/conn_case.ex
new file mode 100644
index 0000000..ae658eb
--- /dev/null
+++ apps/my_app_web/test/support/conn_case.ex
@@ -0,0 +1,37 @@
+defmodule MyAppWeb.ConnCase do
+  @moduledoc """
+  This module defines the test case to be used by
+  tests that require setting up a connection.
+
+  Such tests rely on `Phoenix.ConnTest` and also
+  import other functionality to make it easier
+  to build common data structures and query the data layer.
+
+  Finally, if the test case interacts with the database,
+  we enable the SQL sandbox, so changes done to the database
+  are reverted at the end of every test. If you are using
+  PostgreSQL, you can even run database tests asynchronously
+  by setting `use MyAppWeb.ConnCase, async: true`, although
+  this option is not recommended for other databases.
+  """
+
+  use ExUnit.CaseTemplate
+
+  using do
+    quote do
+      # Import conveniences for testing with connections
+      import Plug.Conn
+      import Phoenix.ConnTest
+      import MyAppWeb.ConnCase
+
+      alias MyAppWeb.Router.Helpers, as: Routes
+
+      # The default endpoint for testing
+      @endpoint MyAppWeb.Endpoint
+    end
+  end
+
+  setup _tags do
+    {:ok, conn: Phoenix.ConnTest.build_conn()}
+  end
+end
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/apps/my_app_web/test/test_helper.exs apps/my_app_web/test/test_helper.exs
new file mode 100644
index 0000000..869559e
--- /dev/null
+++ apps/my_app_web/test/test_helper.exs
@@ -0,0 +1 @@
+ExUnit.start()
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/config/config.exs config/config.exs
new file mode 100644
index 0000000..b6d8a6c
--- /dev/null
+++ config/config.exs
@@ -0,0 +1,35 @@
+# This file is responsible for configuring your umbrella
+# and **all applications** and their dependencies with the
+# help of Mix.Config.
+#
+# Note that all applications in your umbrella share the
+# same configuration and dependencies, which is why they
+# all use the same configuration file. If you want different
+# configurations or dependencies per app, it is best to
+# move said applications out of the umbrella.
+use Mix.Config
+
+
+
+config :my_app_web,
+  generators: [context_app: :my_app, binary_id: true]
+
+# Configures the endpoint
+config :my_app_web, MyAppWeb.Endpoint,
+  url: [host: "localhost"],
+  secret_key_base: "[redacted]",
+  render_errors: [view: MyAppWeb.ErrorView, accepts: ~w(json), layout: false],
+  pubsub_server: MyApp.PubSub,
+  live_view: [signing_salt: "[redacted]"]
+
+# Configures Elixir's Logger
+config :logger, :console,
+  format: "$time $metadata[$level] $message\n",
+  metadata: [:request_id]
+
+# Use Jason for JSON parsing in Phoenix
+config :phoenix, :json_library, Jason
+
+# Import environment specific config. This must remain at the bottom
+# of this file so it overrides the configuration defined above.
+import_config "#{Mix.env()}.exs"
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/config/dev.exs config/dev.exs
new file mode 100644
index 0000000..83402a1
--- /dev/null
+++ config/dev.exs
@@ -0,0 +1,48 @@
+use Mix.Config
+
+# For development, we disable any cache and enable
+# debugging and code reloading.
+#
+# The watchers configuration can be used to run external
+# watchers to your application. For example, we use it
+# with webpack to recompile .js and .css sources.
+config :my_app_web, MyAppWeb.Endpoint,
+  http: [port: 4000],
+  debug_errors: true,
+  code_reloader: true,
+  check_origin: false,
+  watchers: []
+
+# ## SSL Support
+#
+# In order to use HTTPS in development, a self-signed
+# certificate can be generated by running the following
+# Mix task:
+#
+#     mix phx.gen.cert
+#
+# Note that this task requires Erlang/OTP 20 or later.
+# Run `mix help phx.gen.cert` for more information.
+#
+# The `http:` config above can be replaced with:
+#
+#     https: [
+#       port: 4001,
+#       cipher_suite: :strong,
+#       keyfile: "priv/cert/selfsigned_key.pem",
+#       certfile: "priv/cert/selfsigned.pem"
+#     ],
+#
+# If desired, both `http:` and `https:` keys can be
+# configured to run both http and https servers on
+# different ports.
+
+# Do not include metadata nor timestamps in development logs
+config :logger, :console, format: "[$level] $message\n"
+
+# Initialize plugs at runtime for faster development compilation
+config :phoenix, :plug_init_mode, :runtime
+
+# Set a higher stacktrace during development. Avoid configuring such
+# in production as building large stacktraces may be expensive.
+config :phoenix, :stacktrace_depth, 20
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/config/prod.exs config/prod.exs
new file mode 100644
index 0000000..8310ab5
--- /dev/null
+++ config/prod.exs
@@ -0,0 +1,55 @@
+use Mix.Config
+
+# For production, don't forget to configure the url host
+# to something meaningful, Phoenix uses this information
+# when generating URLs.
+#
+# Note we also include the path to a cache manifest
+# containing the digested version of static files. This
+# manifest is generated by the `mix phx.digest` task,
+# which you should run after static files are built and
+# before starting your production server.
+config :my_app_web, MyAppWeb.Endpoint,
+  url: [host: "example.com", port: 80],
+  cache_static_manifest: "priv/static/cache_manifest.json"
+
+# ## SSL Support
+#
+# To get SSL working, you will need to add the `https` key
+# to the previous section and set your `:url` port to 443:
+#
+#     config :my_app_web, MyAppWeb.Endpoint,
+#       ...
+#       url: [host: "example.com", port: 443],
+#       https: [
+#         port: 443,
+#         cipher_suite: :strong,
+#         keyfile: System.get_env("SOME_APP_SSL_KEY_PATH"),
+#         certfile: System.get_env("SOME_APP_SSL_CERT_PATH"),
+#         transport_options: [socket_opts: [:inet6]]
+#       ]
+#
+# The `cipher_suite` is set to `:strong` to support only the
+# latest and more secure SSL ciphers. This means old browsers
+# and clients may not be supported. You can set it to
+# `:compatible` for wider support.
+#
+# `:keyfile` and `:certfile` expect an absolute path to the key
+# and cert in disk or a relative path inside priv, for example
+# "priv/ssl/server.key". For all supported SSL configuration
+# options, see https://hexdocs.pm/plug/Plug.SSL.html#configure/1
+#
+# We also recommend setting `force_ssl` in your endpoint, ensuring
+# no data is ever sent via http, always redirecting to https:
+#
+#     config :my_app_web, MyAppWeb.Endpoint,
+#       force_ssl: [hsts: true]
+#
+# Check `Plug.SSL` for all available options in `force_ssl`.
+
+# Do not print debug messages in production
+config :logger, level: :info
+
+# Finally import the config/prod.secret.exs which loads secrets
+# and configuration from environment variables.
+import_config "prod.secret.exs"
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/config/prod.secret.exs config/prod.secret.exs
new file mode 100644
index 0000000..702c128
--- /dev/null
+++ config/prod.secret.exs
@@ -0,0 +1,29 @@
+# In this file, we load production configuration and secrets
+# from environment variables. You can also hardcode secrets,
+# although such is generally not recommended and you have to
+# remember to add this file to your .gitignore.
+use Mix.Config
+
+secret_key_base =
+  System.get_env("SECRET_KEY_BASE") ||
+    raise """
+    environment variable SECRET_KEY_BASE is missing.
+    You can generate one by calling: mix phx.gen.secret
+    """
+
+config :my_app_web, MyAppWeb.Endpoint,
+  http: [
+    port: String.to_integer(System.get_env("PORT") || "4000"),
+    transport_options: [socket_opts: [:inet6]]
+  ],
+  secret_key_base: secret_key_base
+
+# ## Using releases (Elixir v1.9+)
+#
+# If you are doing OTP releases, you need to instruct Phoenix
+# to start each relevant endpoint:
+#
+#     config :my_app_web, MyAppWeb.Endpoint, server: true
+#
+# Then you can assemble a release by calling `mix release`.
+# See `mix help release` for more information.
diff --git a/projects/phoenix/1.5.7/binaryid-database-noecto-nogettext-nohtml-nowebpack-umbrella/config/test.exs config/test.exs
new file mode 100644
index 0000000..8fd529b
--- /dev/null
+++ config/test.exs
@@ -0,0 +1,10 @@
+use Mix.Config
+
+# We don't run a server during test. If one is required,
+# you can enable the server option below.
+config :my_app_web, MyAppWeb.Endpoint,
+  http: [port: 4002],
+  server: false
+
+# Print only warnings and errors during test
+config :logger, level: :warn
diff --git lib/my_app/application.ex b/projects/elixir/1.11.3/sup/lib/my_app/application.ex
deleted file mode 100644
index 9de1963..0000000
--- lib/my_app/application.ex
+++ /dev/null
@@ -1,20 +0,0 @@
-defmodule MyApp.Application do
-  # See https://hexdocs.pm/elixir/Application.html
-  # for more information on OTP Applications
-  @moduledoc false
-
-  use Application
-
-  @impl true
-  def start(_type, _args) do
-    children = [
-      # Starts a worker by calling: MyApp.Worker.start_link(arg)
-      # {MyApp.Worker, arg}
-    ]
-
-    # See https://hexdocs.pm/elixir/Supervisor.html
-    # for other strategies and supported options
-    opts = [strategy: :one_for_one, name: MyApp.Supervisor]
-    Supervisor.start_link(children, opts)
-  end
-end
diff --git lib/my_app.ex b/projects/elixir/1.11.3/sup/lib/my_app.ex
deleted file mode 100644
index af46ee9..0000000
--- lib/my_app.ex
+++ /dev/null
@@ -1,18 +0,0 @@
-defmodule MyApp do
-  @moduledoc """
-  Documentation for `MyApp`.
-  """
-
-  @doc """
-  Hello world.
-
-  ## Examples
-
-      iex> MyApp.hello()
-      :world
-
-  """
-  def hello do
-    :world
-  end
-end
diff --git mix.exs mix.exs
index 2c85fdb..099c509 100644
--- mix.exs
+++ mix.exs
@@ -1,29 +1,45 @@
-defmodule MyApp.MixProject do
+defmodule MyApp.Umbrella.MixProject do
   use Mix.Project
 
   def project do
     [
-      app: :my_app,
+      apps_path: "apps",
       version: "0.1.0",
-      elixir: "~> 1.11",
       start_permanent: Mix.env() == :prod,
-      deps: deps()
+      deps: deps(),
+      aliases: aliases()
     ]
   end
 
-  # Run "mix help compile.app" to learn about applications.
-  def application do
-    [
-      extra_applications: [:logger],
-      mod: {MyApp.Application, []}
-    ]
+  # Dependencies can be Hex packages:
+  #
+  #   {:mydep, "~> 0.3.0"}
+  #
+  # Or git/path repositories:
+  #
+  #   {:mydep, git: "https://github.com/elixir-lang/mydep.git", tag: "0.1.0"}
+  #
+  # Type "mix help deps" for more examples and options.
+  #
+  # Dependencies listed here are available only for this project
+  # and cannot be accessed from applications inside the apps/ folder.
+  defp deps do
+    []
   end
 
-  # Run "mix help deps" to learn about dependencies.
-  defp deps do
+  # Aliases are shortcuts or tasks specific to the current project.
+  # For example, to install project dependencies and perform other setup tasks, run:
+  #
+  #     $ mix setup
+  #
+  # See the documentation for `Mix` for more info on aliases.
+  #
+  # Aliases listed here are available only for this project
+  # and cannot be accessed from applications inside the apps/ folder.
+  defp aliases do
     [
-      # {:dep_from_hexpm, "~> 0.3.0"},
-      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"}
+      # run `mix setup` in all child apps
+      setup: ["cmd mix setup"]
     ]
   end
 end
diff --git test/my_app_test.exs b/projects/elixir/1.11.3/sup/test/my_app_test.exs
deleted file mode 100644
index b775537..0000000
--- test/my_app_test.exs
+++ /dev/null
@@ -1,8 +0,0 @@
-defmodule MyAppTest do
-  use ExUnit.Case
-  doctest MyApp
-
-  test "greets the world" do
-    assert MyApp.hello() == :world
-  end
-end
