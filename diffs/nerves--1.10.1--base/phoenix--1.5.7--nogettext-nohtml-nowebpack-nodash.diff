diff --git .formatter.exs .formatter.exs
index 8aab4bc..8a6391c 100644
--- .formatter.exs
+++ .formatter.exs
@@ -1,8 +1,5 @@
-# Used by "mix format"
 [
-  inputs: [
-    "{mix,.formatter}.exs",
-    "{config,lib,test}/**/*.{ex,exs}",
-    "rootfs_overlay/etc/iex.exs"
-  ]
+  import_deps: [:ecto, :phoenix],
+  inputs: ["*.{ex,exs}", "priv/*/seeds.exs", "{config,lib,test}/**/*.{ex,exs}"],
+  subdirectories: ["priv/*/migrations"]
 ]
diff --git .gitignore .gitignore
index b03e8b8..be002d1 100644
--- .gitignore
+++ .gitignore
@@ -7,7 +7,7 @@
 # The directory Mix downloads your dependencies sources to.
 /deps/
 
-# Where third-party dependencies like ExDoc output generated docs.
+# Where 3rd-party dependencies like ExDoc output generated docs.
 /doc/
 
 # Ignore .fetch files in case you like to edit your project deps locally.
@@ -15,3 +15,14 @@
 
 # If the VM crashes, it generates a dump, let's ignore it too.
 erl_crash.dump
+
+# Also ignore archive artifacts (built via "mix archive.build").
+*.ez
+
+# Ignore package tarball (built via "mix hex.build").
+my_app-*.tar
+
+# Since we are building assets from assets/,
+# we ignore priv/static. You may want to comment
+# this depending on your deployment strategy.
+/priv/static/
diff --git README.md README.md
index 5d6faed..f59887f 100644
--- README.md
+++ README.md
@@ -1,32 +1,19 @@
 # MyApp
 
-**TODO: Add description**
+To start your Phoenix server:
 
-## Targets
-
-Nerves applications produce images for hardware targets based on the
-`MIX_TARGET` environment variable. If `MIX_TARGET` is unset, `mix` builds an
-image that runs on the host (e.g., your laptop). This is useful for executing
-logic tests, running utilities, and debugging. Other targets are represented by
-a short name like `rpi3` that maps to a Nerves system image for that platform.
-All of this logic is in the generated `mix.exs` and may be customized. For more
-information about targets see:
-
-https://hexdocs.pm/nerves/targets.html#content
+  * Install dependencies with `mix deps.get`
+  * Create and migrate your database with `mix ecto.setup`
+  * Start Phoenix endpoint with `mix phx.server`
 
-## Getting Started
+Now you can visit [`localhost:4000`](http://localhost:4000) from your browser.
 
-To start your Nerves app:
-  * `export MIX_TARGET=my_target` or prefix every command with
-    `MIX_TARGET=my_target`. For example, `MIX_TARGET=rpi3`
-  * Install dependencies with `mix deps.get`
-  * Create firmware with `mix firmware`
-  * Burn to an SD card with `mix firmware.burn`
+Ready to run in production? Please [check our deployment guides](https://hexdocs.pm/phoenix/deployment.html).
 
 ## Learn more
 
-  * Official docs: https://hexdocs.pm/nerves/getting-started.html
-  * Official website: https://nerves-project.org/
-  * Forum: https://elixirforum.com/c/nerves-forum
-  * Discussion Slack elixir-lang #nerves ([Invite](https://elixir-slackin.herokuapp.com/))
-  * Source: https://github.com/nerves-project/nerves
+  * Official website: https://www.phoenixframework.org/
+  * Guides: https://hexdocs.pm/phoenix/overview.html
+  * Docs: https://hexdocs.pm/phoenix
+  * Forum: https://elixirforum.com/c/phoenix-forum
+  * Source: https://github.com/phoenixframework/phoenix
diff --git config/config.exs config/config.exs
index 294fe69..819aaf2 100644
--- config/config.exs
+++ config/config.exs
@@ -3,31 +3,29 @@
 #
 # This configuration file is loaded before any dependency and
 # is restricted to this project.
-import Config
 
-# Enable the Nerves integration with Mix
-Application.start(:nerves_bootstrap)
+# General application configuration
+use Mix.Config
 
-config :my_app, target: Mix.target()
+config :my_app,
+  ecto_repos: [MyApp.Repo]
 
-# Customize non-Elixir parts of the firmware. See
-# https://hexdocs.pm/nerves/advanced-configuration.html for details.
+# Configures the endpoint
+config :my_app, MyAppWeb.Endpoint,
+  url: [host: "localhost"],
+  secret_key_base: "[redacted]",
+  render_errors: [view: MyAppWeb.ErrorView, accepts: ~w(json), layout: false],
+  pubsub_server: MyApp.PubSub,
+  live_view: [signing_salt: "[redacted]"]
 
-config :nerves, :firmware, rootfs_overlay: "rootfs_overlay"
+# Configures Elixir's Logger
+config :logger, :console,
+  format: "$time $metadata[$level] $message\n",
+  metadata: [:request_id]
 
-# Set the SOURCE_DATE_EPOCH date for reproducible builds.
-# See https://reproducible-builds.org/docs/source-date-epoch/ for more information
+# Use Jason for JSON parsing in Phoenix
+config :phoenix, :json_library, Jason
 
-config :nerves, source_date_epoch: "[redacted]"
-
-# Use Ringlogger as the logger backend and remove :console.
-# See https://hexdocs.pm/ring_logger/readme.html for more information on
-# configuring ring_logger.
-
-config :logger, backends: [RingLogger]
-
-if Mix.target() == :host or Mix.target() == :"" do
-  import_config "host.exs"
-else
-  import_config "target.exs"
-end
+# Import environment specific config. This must remain at the bottom
+# of this file so it overrides the configuration defined above.
+import_config "#{Mix.env()}.exs"
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/config/dev.exs config/dev.exs
new file mode 100644
index 0000000..9befbc1
--- /dev/null
+++ config/dev.exs
@@ -0,0 +1,57 @@
+use Mix.Config
+
+# Configure your database
+config :my_app, MyApp.Repo,
+  username: "postgres",
+  password: "postgres",
+  database: "my_app_dev",
+  hostname: "localhost",
+  show_sensitive_data_on_connection_error: true,
+  pool_size: 10
+
+# For development, we disable any cache and enable
+# debugging and code reloading.
+#
+# The watchers configuration can be used to run external
+# watchers to your application. For example, we use it
+# with webpack to recompile .js and .css sources.
+config :my_app, MyAppWeb.Endpoint,
+  http: [port: 4000],
+  debug_errors: true,
+  code_reloader: true,
+  check_origin: false,
+  watchers: []
+
+# ## SSL Support
+#
+# In order to use HTTPS in development, a self-signed
+# certificate can be generated by running the following
+# Mix task:
+#
+#     mix phx.gen.cert
+#
+# Note that this task requires Erlang/OTP 20 or later.
+# Run `mix help phx.gen.cert` for more information.
+#
+# The `http:` config above can be replaced with:
+#
+#     https: [
+#       port: 4001,
+#       cipher_suite: :strong,
+#       keyfile: "priv/cert/selfsigned_key.pem",
+#       certfile: "priv/cert/selfsigned.pem"
+#     ],
+#
+# If desired, both `http:` and `https:` keys can be
+# configured to run both http and https servers on
+# different ports.
+
+# Do not include metadata nor timestamps in development logs
+config :logger, :console, format: "[$level] $message\n"
+
+# Set a higher stacktrace during development. Avoid configuring such
+# in production as building large stacktraces may be expensive.
+config :phoenix, :stacktrace_depth, 20
+
+# Initialize plugs at runtime for faster development compilation
+config :phoenix, :plug_init_mode, :runtime
diff --git config/host.exs b/projects/nerves/1.10.1/base/config/host.exs
deleted file mode 100644
index a1d7678..0000000
--- config/host.exs
+++ /dev/null
@@ -1,3 +0,0 @@
-import Config
-
-# Add configuration that is only needed when running on the host here.
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/config/prod.exs config/prod.exs
new file mode 100644
index 0000000..7443cb4
--- /dev/null
+++ config/prod.exs
@@ -0,0 +1,55 @@
+use Mix.Config
+
+# For production, don't forget to configure the url host
+# to something meaningful, Phoenix uses this information
+# when generating URLs.
+#
+# Note we also include the path to a cache manifest
+# containing the digested version of static files. This
+# manifest is generated by the `mix phx.digest` task,
+# which you should run after static files are built and
+# before starting your production server.
+config :my_app, MyAppWeb.Endpoint,
+  url: [host: "example.com", port: 80],
+  cache_static_manifest: "priv/static/cache_manifest.json"
+
+# Do not print debug messages in production
+config :logger, level: :info
+
+# ## SSL Support
+#
+# To get SSL working, you will need to add the `https` key
+# to the previous section and set your `:url` port to 443:
+#
+#     config :my_app, MyAppWeb.Endpoint,
+#       ...
+#       url: [host: "example.com", port: 443],
+#       https: [
+#         port: 443,
+#         cipher_suite: :strong,
+#         keyfile: System.get_env("SOME_APP_SSL_KEY_PATH"),
+#         certfile: System.get_env("SOME_APP_SSL_CERT_PATH"),
+#         transport_options: [socket_opts: [:inet6]]
+#       ]
+#
+# The `cipher_suite` is set to `:strong` to support only the
+# latest and more secure SSL ciphers. This means old browsers
+# and clients may not be supported. You can set it to
+# `:compatible` for wider support.
+#
+# `:keyfile` and `:certfile` expect an absolute path to the key
+# and cert in disk or a relative path inside priv, for example
+# "priv/ssl/server.key". For all supported SSL configuration
+# options, see https://hexdocs.pm/plug/Plug.SSL.html#configure/1
+#
+# We also recommend setting `force_ssl` in your endpoint, ensuring
+# no data is ever sent via http, always redirecting to https:
+#
+#     config :my_app, MyAppWeb.Endpoint,
+#       force_ssl: [hsts: true]
+#
+# Check `Plug.SSL` for all available options in `force_ssl`.
+
+# Finally import the config/prod.secret.exs which loads secrets
+# and configuration from environment variables.
+import_config "prod.secret.exs"
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/config/prod.secret.exs config/prod.secret.exs
new file mode 100644
index 0000000..968473e
--- /dev/null
+++ config/prod.secret.exs
@@ -0,0 +1,41 @@
+# In this file, we load production configuration and secrets
+# from environment variables. You can also hardcode secrets,
+# although such is generally not recommended and you have to
+# remember to add this file to your .gitignore.
+use Mix.Config
+
+database_url =
+  System.get_env("DATABASE_URL") ||
+    raise """
+    environment variable DATABASE_URL is missing.
+    For example: ecto://USER:PASS@HOST/DATABASE
+    """
+
+config :my_app, MyApp.Repo,
+  # ssl: true,
+  url: database_url,
+  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10")
+
+secret_key_base =
+  System.get_env("SECRET_KEY_BASE") ||
+    raise """
+    environment variable SECRET_KEY_BASE is missing.
+    You can generate one by calling: mix phx.gen.secret
+    """
+
+config :my_app, MyAppWeb.Endpoint,
+  http: [
+    port: String.to_integer(System.get_env("PORT") || "4000"),
+    transport_options: [socket_opts: [:inet6]]
+  ],
+  secret_key_base: secret_key_base
+
+# ## Using releases (Elixir v1.9+)
+#
+# If you are doing OTP releases, you need to instruct Phoenix
+# to start each relevant endpoint:
+#
+#     config :my_app, MyAppWeb.Endpoint, server: true
+#
+# Then you can assemble a release by calling `mix release`.
+# See `mix help release` for more information.
diff --git config/target.exs b/projects/nerves/1.10.1/base/config/target.exs
deleted file mode 100644
index 6f633cc..0000000
--- config/target.exs
+++ /dev/null
@@ -1,100 +0,0 @@
-import Config
-
-# Use shoehorn to start the main application. See the shoehorn
-# docs for separating out critical OTP applications such as those
-# involved with firmware updates.
-
-config :shoehorn,
-  init: [:nerves_runtime, :nerves_pack],
-  app: Mix.Project.config()[:app]
-
-# Nerves Runtime can enumerate hardware devices and send notifications via
-# SystemRegistry. This slows down startup and not many programs make use of
-# this feature.
-
-config :nerves_runtime, :kernel, use_system_registry: false
-
-# Erlinit can be configured without a rootfs_overlay. See
-# https://github.com/nerves-project/erlinit/ for more information on
-# configuring erlinit.
-
-config :nerves,
-  erlinit: [
-    hostname_pattern: "nerves-%s"
-  ]
-
-# Configure the device for SSH IEx prompt access and firmware updates
-#
-# * See https://hexdocs.pm/nerves_ssh/readme.html for general SSH configuration
-# * See https://hexdocs.pm/ssh_subsystem_fwup/readme.html for firmware updates
-
-keys =
-  [
-    Path.join([System.user_home!(), ".ssh", "id_rsa.pub"]),
-    Path.join([System.user_home!(), ".ssh", "id_ecdsa.pub"]),
-    Path.join([System.user_home!(), ".ssh", "id_ed25519.pub"])
-  ]
-  |> Enum.filter(&File.exists?/1)
-
-if keys == [],
-  do:
-    Mix.raise("""
-    No SSH public keys found in ~/.ssh. An ssh authorized key is needed to
-    log into the Nerves device and update firmware on it using ssh.
-    See your project's config.exs for this error message.
-    """)
-
-config :nerves_ssh,
-  authorized_keys: Enum.map(keys, &File.read!/1)
-
-# Configure the network using vintage_net
-# See https://github.com/nerves-networking/vintage_net for more information
-config :vintage_net,
-  regulatory_domain: "US",
-  config: [
-    {"usb0", %{type: VintageNetDirect}},
-    {"eth0",
-     %{
-       type: VintageNetEthernet,
-       ipv4: %{method: :dhcp}
-     }},
-    {"wlan0", %{type: VintageNetWiFi}}
-  ]
-
-config :mdns_lite,
-  # The `host` key specifies what hostnames mdns_lite advertises.  `:hostname`
-  # advertises the device's hostname.local. For the official Nerves systems, this
-  # is "nerves-<4 digit serial#>.local".  mdns_lite also advertises
-  # "nerves.local" for convenience. If more than one Nerves device is on the
-  # network, delete "nerves" from the list.
-
-  host: [:hostname, "nerves"],
-  ttl: 120,
-
-  # Advertise the following services over mDNS.
-  services: [
-    %{
-      name: "SSH Remote Login Protocol",
-      protocol: "ssh",
-      transport: "tcp",
-      port: 22
-    },
-    %{
-      name: "Secure File Transfer Protocol over SSH",
-      protocol: "sftp-ssh",
-      transport: "tcp",
-      port: 22
-    },
-    %{
-      name: "Erlang Port Mapper Daemon",
-      protocol: "epmd",
-      transport: "tcp",
-      port: 4369
-    }
-  ]
-
-# Import target specific config. This must remain at the bottom
-# of this file so it overrides the configuration defined above.
-# Uncomment to use target specific configurations
-
-# import_config "#{Mix.target()}.exs"
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/config/test.exs config/test.exs
new file mode 100644
index 0000000..5589099
--- /dev/null
+++ config/test.exs
@@ -0,0 +1,22 @@
+use Mix.Config
+
+# Configure your database
+#
+# The MIX_TEST_PARTITION environment variable can be used
+# to provide built-in test partitioning in CI environment.
+# Run `mix help test` for more information.
+config :my_app, MyApp.Repo,
+  username: "postgres",
+  password: "postgres",
+  database: "my_app_test#{System.get_env("MIX_TEST_PARTITION")}",
+  hostname: "localhost",
+  pool: Ecto.Adapters.SQL.Sandbox
+
+# We don't run a server during test. If one is required,
+# you can enable the server option below.
+config :my_app, MyAppWeb.Endpoint,
+  http: [port: 4002],
+  server: false
+
+# Print only warnings and errors during test
+config :logger, level: :warn
diff --git lib/my_app/application.ex lib/my_app/application.ex
index d57e31e..fd03945 100644
--- lib/my_app/application.ex
+++ lib/my_app/application.ex
@@ -6,38 +6,29 @@ defmodule MyApp.Application do
   use Application
 
   def start(_type, _args) do
+    children = [
+      # Start the Ecto repository
+      MyApp.Repo,
+      # Start the Telemetry supervisor
+      MyAppWeb.Telemetry,
+      # Start the PubSub system
+      {Phoenix.PubSub, name: MyApp.PubSub},
+      # Start the Endpoint (http/https)
+      MyAppWeb.Endpoint
+      # Start a worker by calling: MyApp.Worker.start_link(arg)
+      # {MyApp.Worker, arg}
+    ]
+
     # See https://hexdocs.pm/elixir/Supervisor.html
     # for other strategies and supported options
     opts = [strategy: :one_for_one, name: MyApp.Supervisor]
-
-    children =
-      [
-        # Children for all targets
-        # Starts a worker by calling: MyApp.Worker.start_link(arg)
-        # {MyApp.Worker, arg},
-      ] ++ children(target())
-
     Supervisor.start_link(children, opts)
   end
 
-  # List all child processes to be supervised
-  def children(:host) do
-    [
-      # Children that only run on the host
-      # Starts a worker by calling: MyApp.Worker.start_link(arg)
-      # {MyApp.Worker, arg},
-    ]
-  end
-
-  def children(_target) do
-    [
-      # Children for all targets except host
-      # Starts a worker by calling: MyApp.Worker.start_link(arg)
-      # {MyApp.Worker, arg},
-    ]
-  end
-
-  def target() do
-    Application.get_env(:my_app, :target)
+  # Tell Phoenix to update the endpoint configuration
+  # whenever the application is updated.
+  def config_change(changed, _new, removed) do
+    MyAppWeb.Endpoint.config_change(changed, removed)
+    :ok
   end
 end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/lib/my_app/repo.ex lib/my_app/repo.ex
new file mode 100644
index 0000000..595ff57
--- /dev/null
+++ lib/my_app/repo.ex
@@ -0,0 +1,5 @@
+defmodule MyApp.Repo do
+  use Ecto.Repo,
+    otp_app: :my_app,
+    adapter: Ecto.Adapters.Postgres
+end
diff --git lib/my_app.ex lib/my_app.ex
index a67da57..ee0175f 100644
--- lib/my_app.ex
+++ lib/my_app.ex
@@ -1,18 +1,9 @@
 defmodule MyApp do
   @moduledoc """
-  Documentation for MyApp.
-  """
-
-  @doc """
-  Hello world.
-
-  ## Examples
-
-      iex> MyApp.hello
-      :world
+  MyApp keeps the contexts that define your domain
+  and business logic.
 
+  Contexts are also responsible for managing your data, regardless
+  if it comes from the database, an external API or others.
   """
-  def hello do
-    :world
-  end
 end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/lib/my_app_web/channels/user_socket.ex lib/my_app_web/channels/user_socket.ex
new file mode 100644
index 0000000..2b7368f
--- /dev/null
+++ lib/my_app_web/channels/user_socket.ex
@@ -0,0 +1,35 @@
+defmodule MyAppWeb.UserSocket do
+  use Phoenix.Socket
+
+  ## Channels
+  # channel "room:*", MyAppWeb.RoomChannel
+
+  # Socket params are passed from the client and can
+  # be used to verify and authenticate a user. After
+  # verification, you can put default assigns into
+  # the socket that will be set for all channels, ie
+  #
+  #     {:ok, assign(socket, :user_id, verified_user_id)}
+  #
+  # To deny connection, return `:error`.
+  #
+  # See `Phoenix.Token` documentation for examples in
+  # performing token verification on connect.
+  @impl true
+  def connect(_params, socket, _connect_info) do
+    {:ok, socket}
+  end
+
+  # Socket id's are topics that allow you to identify all sockets for a given user:
+  #
+  #     def id(socket), do: "user_socket:#{socket.assigns.user_id}"
+  #
+  # Would allow you to broadcast a "disconnect" event and terminate
+  # all active sockets and channels for a given user:
+  #
+  #     MyAppWeb.Endpoint.broadcast("user_socket:#{user.id}", "disconnect", %{})
+  #
+  # Returning `nil` makes this socket anonymous.
+  @impl true
+  def id(_socket), do: nil
+end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/lib/my_app_web/endpoint.ex lib/my_app_web/endpoint.ex
new file mode 100644
index 0000000..8e2fda4
--- /dev/null
+++ lib/my_app_web/endpoint.ex
@@ -0,0 +1,46 @@
+defmodule MyAppWeb.Endpoint do
+  use Phoenix.Endpoint, otp_app: :my_app
+
+  # The session will be stored in the cookie and signed,
+  # this means its contents can be read but not tampered with.
+  # Set :encryption_salt if you would also like to encrypt it.
+  @session_options [
+    store: :cookie,
+    key: "_my_app_key",
+    signing_salt: "[redacted]"
+  ]
+
+  socket "/socket", MyAppWeb.UserSocket,
+    websocket: true,
+    longpoll: false
+
+  # Serve at "/" the static files from "priv/static" directory.
+  #
+  # You should set gzip to true if you are running phx.digest
+  # when deploying your static files in production.
+  plug Plug.Static,
+    at: "/",
+    from: :my_app,
+    gzip: false,
+    only: ~w(css fonts images js favicon.ico robots.txt)
+
+  # Code reloading can be explicitly enabled under the
+  # :code_reloader configuration of your endpoint.
+  if code_reloading? do
+    plug Phoenix.CodeReloader
+    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :my_app
+  end
+
+  plug Plug.RequestId
+  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]
+
+  plug Plug.Parsers,
+    parsers: [:urlencoded, :multipart, :json],
+    pass: ["*/*"],
+    json_decoder: Phoenix.json_library()
+
+  plug Plug.MethodOverride
+  plug Plug.Head
+  plug Plug.Session, @session_options
+  plug MyAppWeb.Router
+end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/lib/my_app_web/router.ex lib/my_app_web/router.ex
new file mode 100644
index 0000000..5f5f6fc
--- /dev/null
+++ lib/my_app_web/router.ex
@@ -0,0 +1,11 @@
+defmodule MyAppWeb.Router do
+  use MyAppWeb, :router
+
+  pipeline :api do
+    plug :accepts, ["json"]
+  end
+
+  scope "/api", MyAppWeb do
+    pipe_through :api
+  end
+end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/lib/my_app_web/telemetry.ex lib/my_app_web/telemetry.ex
new file mode 100644
index 0000000..2c9c8ae
--- /dev/null
+++ lib/my_app_web/telemetry.ex
@@ -0,0 +1,55 @@
+defmodule MyAppWeb.Telemetry do
+  use Supervisor
+  import Telemetry.Metrics
+
+  def start_link(arg) do
+    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
+  end
+
+  @impl true
+  def init(_arg) do
+    children = [
+      # Telemetry poller will execute the given period measurements
+      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
+      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
+      # Add reporters as children of your supervision tree.
+      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
+    ]
+
+    Supervisor.init(children, strategy: :one_for_one)
+  end
+
+  def metrics do
+    [
+      # Phoenix Metrics
+      summary("phoenix.endpoint.stop.duration",
+        unit: {:native, :millisecond}
+      ),
+      summary("phoenix.router_dispatch.stop.duration",
+        tags: [:route],
+        unit: {:native, :millisecond}
+      ),
+
+      # Database Metrics
+      summary("my_app.repo.query.total_time", unit: {:native, :millisecond}),
+      summary("my_app.repo.query.decode_time", unit: {:native, :millisecond}),
+      summary("my_app.repo.query.query_time", unit: {:native, :millisecond}),
+      summary("my_app.repo.query.queue_time", unit: {:native, :millisecond}),
+      summary("my_app.repo.query.idle_time", unit: {:native, :millisecond}),
+
+      # VM Metrics
+      summary("vm.memory.total", unit: {:byte, :kilobyte}),
+      summary("vm.total_run_queue_lengths.total"),
+      summary("vm.total_run_queue_lengths.cpu"),
+      summary("vm.total_run_queue_lengths.io")
+    ]
+  end
+
+  defp periodic_measurements do
+    [
+      # A module, function and arguments to be invoked periodically.
+      # This function must call :telemetry.execute/3 and a metric must be added above.
+      # {MyAppWeb, :count_users, []}
+    ]
+  end
+end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/lib/my_app_web/views/error_helpers.ex lib/my_app_web/views/error_helpers.ex
new file mode 100644
index 0000000..dd1c1c4
--- /dev/null
+++ lib/my_app_web/views/error_helpers.ex
@@ -0,0 +1,16 @@
+defmodule MyAppWeb.ErrorHelpers do
+  @moduledoc """
+  Conveniences for translating and building error messages.
+  """
+
+  @doc """
+  Translates an error message.
+  """
+  def translate_error({msg, opts}) do
+    # Because the error messages we show in our forms and APIs
+    # are defined inside Ecto, we need to translate them dynamically.
+    Enum.reduce(opts, msg, fn {key, value}, acc ->
+      String.replace(acc, "%{#{key}}", to_string(value))
+    end)
+  end
+end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/lib/my_app_web/views/error_view.ex lib/my_app_web/views/error_view.ex
new file mode 100644
index 0000000..6bc5b14
--- /dev/null
+++ lib/my_app_web/views/error_view.ex
@@ -0,0 +1,16 @@
+defmodule MyAppWeb.ErrorView do
+  use MyAppWeb, :view
+
+  # If you want to customize a particular status code
+  # for a certain format, you may uncomment below.
+  # def render("500.json", _assigns) do
+  #   %{errors: %{detail: "Internal Server Error"}}
+  # end
+
+  # By default, Phoenix returns the status message from
+  # the template name. For example, "404.json" becomes
+  # "Not Found".
+  def template_not_found(template, _assigns) do
+    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}
+  end
+end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/lib/my_app_web.ex lib/my_app_web.ex
new file mode 100644
index 0000000..1f75dac
--- /dev/null
+++ lib/my_app_web.ex
@@ -0,0 +1,75 @@
+defmodule MyAppWeb do
+  @moduledoc """
+  The entrypoint for defining your web interface, such
+  as controllers, views, channels and so on.
+
+  This can be used in your application as:
+
+      use MyAppWeb, :controller
+      use MyAppWeb, :view
+
+  The definitions below will be executed for every view,
+  controller, etc, so keep them short and clean, focused
+  on imports, uses and aliases.
+
+  Do NOT define functions inside the quoted expressions
+  below. Instead, define any helper function in modules
+  and import those modules here.
+  """
+
+  def controller do
+    quote do
+      use Phoenix.Controller, namespace: MyAppWeb
+
+      import Plug.Conn
+      alias MyAppWeb.Router.Helpers, as: Routes
+    end
+  end
+
+  def view do
+    quote do
+      use Phoenix.View,
+        root: "lib/my_app_web/templates",
+        namespace: MyAppWeb
+
+      # Import convenience functions from controllers
+      import Phoenix.Controller,
+        only: [get_flash: 1, get_flash: 2, view_module: 1, view_template: 1]
+
+      # Include shared imports and aliases for views
+      unquote(view_helpers())
+    end
+  end
+
+  def router do
+    quote do
+      use Phoenix.Router
+
+      import Plug.Conn
+      import Phoenix.Controller
+    end
+  end
+
+  def channel do
+    quote do
+      use Phoenix.Channel
+    end
+  end
+
+  defp view_helpers do
+    quote do
+      # Import basic rendering functionality (render, render_layout, etc)
+      import Phoenix.View
+
+      import MyAppWeb.ErrorHelpers
+      alias MyAppWeb.Router.Helpers, as: Routes
+    end
+  end
+
+  @doc """
+  When used, dispatch to the appropriate controller/view/etc.
+  """
+  defmacro __using__(which) when is_atom(which) do
+    apply(__MODULE__, which, [])
+  end
+end
diff --git mix.exs mix.exs
index 0d28119..bc5e674 100644
--- mix.exs
+++ mix.exs
@@ -1,25 +1,22 @@
 defmodule MyApp.MixProject do
   use Mix.Project
 
-  @app :my_app
-  @version "0.1.0"
-  @all_targets [:rpi, :rpi0, :rpi2, :rpi3, :rpi3a, :rpi4, :bbb, :osd32mp1, :x86_64]
-
   def project do
     [
-      app: @app,
-      version: @version,
-      elixir: "~> 1.9",
-      archives: [nerves_bootstrap: "~> 1.10"],
+      app: :my_app,
+      version: "0.1.0",
+      elixir: "~> 1.7",
+      elixirc_paths: elixirc_paths(Mix.env()),
+      compilers: [:phoenix] ++ Mix.compilers(),
       start_permanent: Mix.env() == :prod,
-      build_embedded: true,
-      deps: deps(),
-      releases: [{@app, release()}],
-      preferred_cli_target: [run: :host, test: :host]
+      aliases: aliases(),
+      deps: deps()
     ]
   end
 
-  # Run "mix help compile.app" to learn about applications.
+  # Configuration for the OTP application.
+  #
+  # Type `mix help compile.app` for more information.
   def application do
     [
       mod: {MyApp.Application, []},
@@ -27,39 +24,38 @@ defmodule MyApp.MixProject do
     ]
   end
 
-  # Run "mix help deps" to learn about dependencies.
+  # Specifies which paths to compile per environment.
+  defp elixirc_paths(:test), do: ["lib", "test/support"]
+  defp elixirc_paths(_), do: ["lib"]
+
+  # Specifies your project dependencies.
+  #
+  # Type `mix help deps` for examples and options.
   defp deps do
     [
-      # Dependencies for all targets
-      {:nerves, "~> 1.7.0", runtime: false},
-      {:shoehorn, "~> 0.7.0"},
-      {:ring_logger, "~> 0.8.1"},
-      {:toolshed, "~> 0.2.13"},
-
-      # Dependencies for all targets except :host
-      {:nerves_runtime, "~> 0.11.3", targets: @all_targets},
-      {:nerves_pack, "~> 0.4.0", targets: @all_targets},
-
-      # Dependencies for specific targets
-      {:nerves_system_rpi, "~> 1.13", runtime: false, targets: :rpi},
-      {:nerves_system_rpi0, "~> 1.13", runtime: false, targets: :rpi0},
-      {:nerves_system_rpi2, "~> 1.13", runtime: false, targets: :rpi2},
-      {:nerves_system_rpi3, "~> 1.13", runtime: false, targets: :rpi3},
-      {:nerves_system_rpi3a, "~> 1.13", runtime: false, targets: :rpi3a},
-      {:nerves_system_rpi4, "~> 1.13", runtime: false, targets: :rpi4},
-      {:nerves_system_bbb, "~> 2.8", runtime: false, targets: :bbb},
-      {:nerves_system_osd32mp1, "~> 0.4", runtime: false, targets: :osd32mp1},
-      {:nerves_system_x86_64, "~> 1.13", runtime: false, targets: :x86_64}
+      {:phoenix, "~> 1.5.7"},
+      {:phoenix_ecto, "~> 4.1"},
+      {:ecto_sql, "~> 3.4"},
+      {:postgrex, ">= 0.0.0"},
+      {:telemetry_metrics, "~> 0.4"},
+      {:telemetry_poller, "~> 0.4"},
+      {:jason, "~> 1.0"},
+      {:plug_cowboy, "~> 2.0"}
     ]
   end
 
-  def release do
+  # Aliases are shortcuts or tasks specific to the current project.
+  # For example, to install project dependencies and perform other setup tasks, run:
+  #
+  #     $ mix setup
+  #
+  # See the documentation for `Mix` for more info on aliases.
+  defp aliases do
     [
-      overwrite: true,
-      cookie: "#{@app}_cookie",
-      include_erts: &Nerves.Release.erts/0,
-      steps: [&Nerves.Release.init/1, :assemble],
-      strip_beams: Mix.env() == :prod
+      setup: ["deps.get", "ecto.setup"],
+      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
+      "ecto.reset": ["ecto.drop", "ecto.setup"],
+      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"]
     ]
   end
 end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/priv/repo/migrations/.formatter.exs priv/repo/migrations/.formatter.exs
new file mode 100644
index 0000000..49f9151
--- /dev/null
+++ priv/repo/migrations/.formatter.exs
@@ -0,0 +1,4 @@
+[
+  import_deps: [:ecto_sql],
+  inputs: ["*.exs"]
+]
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/priv/repo/seeds.exs priv/repo/seeds.exs
new file mode 100644
index 0000000..e4ba004
--- /dev/null
+++ priv/repo/seeds.exs
@@ -0,0 +1,11 @@
+# Script for populating the database. You can run it as:
+#
+#     mix run priv/repo/seeds.exs
+#
+# Inside the script, you can read and write to any of your
+# repositories directly:
+#
+#     MyApp.Repo.insert!(%MyApp.SomeSchema{})
+#
+# We recommend using the bang functions (`insert!`, `update!`
+# and so on) as they will fail if something goes wrong.
diff --git rel/vm.args.eex b/projects/nerves/1.10.1/base/rel/vm.args.eex
deleted file mode 100644
index 42154b1..0000000
--- rel/vm.args.eex
+++ /dev/null
@@ -1,49 +0,0 @@
-## Add custom options here
-
-## Distributed Erlang Options
-##  The cookie needs to be configured prior to vm boot for
-##  for read only filesystem.
-
--setcookie <%= @release.options[:cookie] %>
-
-## Use Ctrl-C to interrupt the current shell rather than invoking the emulator's
-## break handler and possibly exiting the VM.
-+Bc
-
-# Allow time warps so that the Erlang system time can more closely match the
-# OS system time.
-+C multi_time_warp
-
-## Load code at system startup
-## See http://erlang.org/doc/system_principles/system_principles.html#code-loading-strategy
--mode embedded
-
-## Disable scheduler busy wait to reduce idle CPU usage and avoid delaying
-## other OS processes. See http://erlang.org/doc/man/erl.html#+sbwt
-+sbwt none
-+sbwtdcpu none
-+sbwtdio none
-
-## Save the shell history between reboots
-## See http://erlang.org/doc/man/kernel_app.html for additional options
--kernel shell_history enabled
-
-## Enable heartbeat monitoring of the Erlang runtime system
--heart -env HEART_BEAT_TIMEOUT 30
-
-## Start the Elixir shell
-
--noshell
--user Elixir.IEx.CLI
-
-## Enable colors in the shell
--elixir ansi_enabled true
-
-## Options added after -extra are interpreted as plain arguments and can be
-## retrieved using :init.get_plain_arguments(). Options before the "--" are
-## interpreted by Elixir and anything afterwards is left around for other IEx
-## and user applications.
--extra --no-halt
---
---dot-iex /etc/iex.exs
-
diff --git rootfs_overlay/etc/iex.exs b/projects/nerves/1.10.1/base/rootfs_overlay/etc/iex.exs
deleted file mode 100644
index 5cccb30..0000000
--- rootfs_overlay/etc/iex.exs
+++ /dev/null
@@ -1,15 +0,0 @@
-# Add Toolshed helpers to the IEx session
-use Toolshed
-
-if RingLogger in Application.get_env(:logger, :backends, []) do
-  IO.puts("""
-  RingLogger is collecting log messages from Elixir and Linux. To see the
-  messages, either attach the current IEx session to the logger:
-
-    RingLogger.attach
-
-  or print the next messages in the log:
-
-    RingLogger.next
-  """)
-end
diff --git test/my_app_test.exs b/projects/nerves/1.10.1/base/test/my_app_test.exs
deleted file mode 100644
index b775537..0000000
--- test/my_app_test.exs
+++ /dev/null
@@ -1,8 +0,0 @@
-defmodule MyAppTest do
-  use ExUnit.Case
-  doctest MyApp
-
-  test "greets the world" do
-    assert MyApp.hello() == :world
-  end
-end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/test/my_app_web/views/error_view_test.exs test/my_app_web/views/error_view_test.exs
new file mode 100644
index 0000000..05a065b
--- /dev/null
+++ test/my_app_web/views/error_view_test.exs
@@ -0,0 +1,15 @@
+defmodule MyAppWeb.ErrorViewTest do
+  use MyAppWeb.ConnCase, async: true
+
+  # Bring render/3 and render_to_string/3 for testing custom views
+  import Phoenix.View
+
+  test "renders 404.json" do
+    assert render(MyAppWeb.ErrorView, "404.json", []) == %{errors: %{detail: "Not Found"}}
+  end
+
+  test "renders 500.json" do
+    assert render(MyAppWeb.ErrorView, "500.json", []) ==
+             %{errors: %{detail: "Internal Server Error"}}
+  end
+end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/test/support/channel_case.ex test/support/channel_case.ex
new file mode 100644
index 0000000..831b300
--- /dev/null
+++ test/support/channel_case.ex
@@ -0,0 +1,40 @@
+defmodule MyAppWeb.ChannelCase do
+  @moduledoc """
+  This module defines the test case to be used by
+  channel tests.
+
+  Such tests rely on `Phoenix.ChannelTest` and also
+  import other functionality to make it easier
+  to build common data structures and query the data layer.
+
+  Finally, if the test case interacts with the database,
+  we enable the SQL sandbox, so changes done to the database
+  are reverted at the end of every test. If you are using
+  PostgreSQL, you can even run database tests asynchronously
+  by setting `use MyAppWeb.ChannelCase, async: true`, although
+  this option is not recommended for other databases.
+  """
+
+  use ExUnit.CaseTemplate
+
+  using do
+    quote do
+      # Import conveniences for testing with channels
+      import Phoenix.ChannelTest
+      import MyAppWeb.ChannelCase
+
+      # The default endpoint for testing
+      @endpoint MyAppWeb.Endpoint
+    end
+  end
+
+  setup tags do
+    :ok = Ecto.Adapters.SQL.Sandbox.checkout(MyApp.Repo)
+
+    unless tags[:async] do
+      Ecto.Adapters.SQL.Sandbox.mode(MyApp.Repo, {:shared, self()})
+    end
+
+    :ok
+  end
+end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/test/support/conn_case.ex test/support/conn_case.ex
new file mode 100644
index 0000000..a1d99dc
--- /dev/null
+++ test/support/conn_case.ex
@@ -0,0 +1,43 @@
+defmodule MyAppWeb.ConnCase do
+  @moduledoc """
+  This module defines the test case to be used by
+  tests that require setting up a connection.
+
+  Such tests rely on `Phoenix.ConnTest` and also
+  import other functionality to make it easier
+  to build common data structures and query the data layer.
+
+  Finally, if the test case interacts with the database,
+  we enable the SQL sandbox, so changes done to the database
+  are reverted at the end of every test. If you are using
+  PostgreSQL, you can even run database tests asynchronously
+  by setting `use MyAppWeb.ConnCase, async: true`, although
+  this option is not recommended for other databases.
+  """
+
+  use ExUnit.CaseTemplate
+
+  using do
+    quote do
+      # Import conveniences for testing with connections
+      import Plug.Conn
+      import Phoenix.ConnTest
+      import MyAppWeb.ConnCase
+
+      alias MyAppWeb.Router.Helpers, as: Routes
+
+      # The default endpoint for testing
+      @endpoint MyAppWeb.Endpoint
+    end
+  end
+
+  setup tags do
+    :ok = Ecto.Adapters.SQL.Sandbox.checkout(MyApp.Repo)
+
+    unless tags[:async] do
+      Ecto.Adapters.SQL.Sandbox.mode(MyApp.Repo, {:shared, self()})
+    end
+
+    {:ok, conn: Phoenix.ConnTest.build_conn()}
+  end
+end
diff --git a/projects/phoenix/1.5.7/nogettext-nohtml-nowebpack-nodash/test/support/data_case.ex test/support/data_case.ex
new file mode 100644
index 0000000..774d271
--- /dev/null
+++ test/support/data_case.ex
@@ -0,0 +1,55 @@
+defmodule MyApp.DataCase do
+  @moduledoc """
+  This module defines the setup for tests requiring
+  access to the application's data layer.
+
+  You may define functions here to be used as helpers in
+  your tests.
+
+  Finally, if the test case interacts with the database,
+  we enable the SQL sandbox, so changes done to the database
+  are reverted at the end of every test. If you are using
+  PostgreSQL, you can even run database tests asynchronously
+  by setting `use MyApp.DataCase, async: true`, although
+  this option is not recommended for other databases.
+  """
+
+  use ExUnit.CaseTemplate
+
+  using do
+    quote do
+      alias MyApp.Repo
+
+      import Ecto
+      import Ecto.Changeset
+      import Ecto.Query
+      import MyApp.DataCase
+    end
+  end
+
+  setup tags do
+    :ok = Ecto.Adapters.SQL.Sandbox.checkout(MyApp.Repo)
+
+    unless tags[:async] do
+      Ecto.Adapters.SQL.Sandbox.mode(MyApp.Repo, {:shared, self()})
+    end
+
+    :ok
+  end
+
+  @doc """
+  A helper that transforms changeset errors into a map of messages.
+
+      assert {:error, changeset} = Accounts.create_user(%{password: "short"})
+      assert "password is too short" in errors_on(changeset).password
+      assert %{password: ["password is too short"]} = errors_on(changeset)
+
+  """
+  def errors_on(changeset) do
+    Ecto.Changeset.traverse_errors(changeset, fn {message, opts} ->
+      Regex.replace(~r"%{(\w+)}", message, fn _, key ->
+        opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
+      end)
+    end)
+  end
+end
diff --git test/test_helper.exs test/test_helper.exs
index 869559e..0491a89 100644
--- test/test_helper.exs
+++ test/test_helper.exs
@@ -1 +1,2 @@
 ExUnit.start()
+Ecto.Adapters.SQL.Sandbox.mode(MyApp.Repo, :manual)
